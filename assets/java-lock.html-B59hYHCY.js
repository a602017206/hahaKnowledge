import{_ as o,o as t,c as l,a as n,b as e}from"./app-CutjyUmw.js";const s={},c=n("p",null,[n("strong",null,"1.乐观锁"),e(" 认为读多写少，在读的时候不加锁，只有在更新时才判断期间有没有人改过这个数据，采取先读取版本号，再加锁操作，通过CAS实现，CAS就是比较和更新，每次更新时会比较当前值和修改前的值是否一致，一致则修改，不一致则返回false")],-1),_=n("p",null,[n("strong",null,"2.悲观锁"),e(" 认为写多，每次都加锁，Synchronized就是一种悲观锁")],-1),a=n("p",null,[n("strong",null,"3.自旋锁"),e(" 等待竞争锁的线程可以在很短的时间内释放锁资源，那么等待竞争锁的线程就不需要做内核态和用户态的之间切换进入阻塞挂起状态，它们只需要等一等（自旋），等待有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。")],-1),r=n("p",null,[n("strong",null,"4.synchronized同步锁"),e(" 它可以把任意非的null的对象当做锁。它属于独占式的悲观锁，同时属于可重入锁。")],-1),u=[c,_,a,r];function d(i,h){return t(),l("div",null,u)}const p=o(s,[["render",d],["__file","java-lock.html.vue"]]);export{p as default};
